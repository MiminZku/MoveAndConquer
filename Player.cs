using Photon.Pun;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Hashtable = ExitGames.Client.Photon.Hashtable;

public class Player : MonoBehaviourPun
{
    private bool isObstacleSelected;
    private bool isMoveInput = false;

    public Tile[,] board;
    Index currentIndex;

    public List<Index> pathBuffer = new List<Index>();
    int inputMoveCount;


    MeshRenderer meshRenderer;
    public Material player1Mat;
    public Material player2Mat;


    // Start is called before the first frame update
    void Start()
    {
        inputMoveCount = 0;
        board = GameManager.Instance.board;
        if (transform.position == GameManager.Instance.spawnPositions[0].position) {
            currentIndex.row = 6;
            currentIndex.column = 2;
        }
        if (transform.position == GameManager.Instance.spawnPositions[1].position) {
            currentIndex.row = 2;
            currentIndex.column = 2;
        }


        PhotonNetwork.LocalPlayer.SetCustomProperties(new Hashtable { { "isInputDone", false } });
        meshRenderer = GetComponent<MeshRenderer>();
        if (photonView.IsMine)
        {
            meshRenderer.material = player1Mat;
        }
        else
        {
            meshRenderer.material = player2Mat;
        }
    }

    // Update is called once per frame
    void Update()
    {

        if (isMoveInput && inputMoveCount < GameManager.Instance.diceNum) // *** 객체 hit 함수 추가
        {
            if (Input.GetKeyDown(KeyCode.W))
            {
                /*Column 1 감소, 실제로 이동시켜야지. 얘는 0일때 못가게 하면 되지.*/
                if (currentIndex.column == 0)
                {
                    Debug.Log("Way Blocked!");
                }
                else
                { // 이동 가능. column 1 감소 후 
                    currentIndex.column -= 1;
                    pathBuffer.add(currentIndex);
                    inputMoveCount++;
                }

            }
            else if (Input.GetKeyDown(KeyCode.A))
            {
                if (currentIndex.row == 0)
                {
                    Debug.Log("Way Blocked!");
                }
                else
                { // 이동 가능. row 1 감소 후 
                    currentIndex.row -= 1;
                    pathBuffer.add(currentIndex);
                    inputMoveCount++;
                }

            }
            else if (Input.GetKeyDown(KeyCode.S))
            {
                if (currentIndex.column == 8)
                {
                    Debug.Log("Way Blocked!");
                }
                else
                { // 이동 가능. column 1 증가 후 
                    currentIndex.column += 1;
                    pathBuffer.add(currentIndex);
                    inputMoveCount++;
                }

            }
            else if (Input.GetKeyDown(KeyCode.D))
            {
                if (currentIndex.row == 4)
                {
                    Debug.Log("Way Blocked!");
                }
                else
                { // 이동 가능. row 1 증가 후 
                    currentIndex.row += 1;
                    pathBuffer.add(currentIndex);
                    inputMoveCount++;
                }

            }

        }
        else { 
            /*network stuff*/
        }
    }

    public void OnObstacleButtonClick()
    {
        isObstacleSelected = true;
    }

    public void OnMoveButtonClick()
    {
        isObstacleSelected = false;
        pathBuffer.Clear();
    }


    // *클릭으로 입력받고 클릭한 클릭한 타일의 isObstacle flag를 변경해줌
    public void InputObstacle()
    {
        // flag 를 이 함수에서 바꿔주고 Update() 에서 입력을 받기
        // flag는 입력을 받을 수 잇는 상태를 나타냄
        // 아래 코드가 꼭 이 함수 안에 있어야하는 거는 아님. update() 문에서도 사용 가능.

        // *클릭한 타일의 row와 col을 가져와서 tileRow, tileCol 변수에 대입
        // tile 클래스에 tileIndex 이용
        int tileRow = 3;
        int tileCol = 3;
        // *NewGameMgr에서 time이 초과되면 입력받기 중지
        // NewGameMgr의 변수 currentTime, maxTime 이용

        // network 
        // iaObastacle flag 변경해주는 코드
        // 필요에 따라 위치 이동
        PhotonView pv = gameObject.GetPhotonView();
        pv.RPC("SetObstacleFlag", RpcTarget.AllBuffered, tileRow, tileCol);
        PhotonNetwork.LocalPlayer.SetCustomProperties(new Hashtable { { "isInputDone", true } });
    }

    // *이동을 입력받고 이동 경로를 NewPlayer 클래스가 가지고 있는 pathBuffer 변수에 저장.
    public void InputMove(int diceNum)
    {

        inputMoveCount = 0;

        // flag 를 이 함수에서 바꿔주고 Update() 에서 입력을 받기
        // flag는 입력을 받을 수 잇는 상태를 나타냄
        // 이동 입력받기는 InputObstacle() 함수와 마찬가지로 Update() 문에서 받기
        // 마찬가지로 flag 필요
        // 입력받으면서 player 오브젝트(체스 말) 이동 필요
        // 매개변수로 받은 diceNum 만큼 입력 받기
        // 모든 값을 다 입력받으면 원래 위치로 이동.
        
       

        // *NewGameMgr에서 time이 초과되면 입력받기 중지
        // NewGameMgr의 변수 currentTime, maxTime 이용


        // network
        PhotonView pv = gameObject.GetPhotonView();
        pv.RPC("SetObstacleFlag", RpcTarget.AllBuffered, tileRow, tileCol);
        PhotonNetwork.LocalPlayer.SetCustomProperties(new Hashtable { { "isInputDone", true } });
    }

    // RPC 함수
    [PunRPC]
    public void SetObstacleFlag(int indexRow, int indexCol)
    {
        //flag 새우기
        board[indexRow, indexCol].isObstacle = true;
    }
    [PunRPC]
    public void SetObstacle(int indexRow, int indexCol)
    {
        //
    }

}

